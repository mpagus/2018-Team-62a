#pragma config(Sensor, in1,    stage2Encoder,  sensorPotentiometer)
#pragma config(Sensor, in2,    intakeEncoder,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  coneIntake,     sensorDigitalOut)
#pragma config(Sensor, dgtl2,  stage1Encoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  highGoalLight,  sensorDigitalOut)
#pragma config(Motor,  port1,           rightDrive2,   tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port3,           leftDrive2,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           stage1L,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           intakeR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           intakeL,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftDrive1,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rightDrive1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           stage1R,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          stage2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

float desiredStage1 = 0;
float desiredStage2 = 0;
float stage2Limit = 0;
bool mobileGoal = true;
bool stage1Change = true;
bool highGoal = false;
int currentConeStack = 0;
int currentHighConeStack = 0;
bool autonCompleted = false;

int limit(int val, int min = -127, int max = 127){
	if(val>max){
		return max;
	}
	if(val<min){
		return min;
	}
	return val;
}

bool deadband(int val, int target, int db = 10){
	return val > target + db || val < -target - db;
}

void towerStage1(int val){
	motor[stage1L] = motor[stage1R] = val;
}

void towerStage2(int val){
	motor[stage2] = val;
}

void intake(int val){
	motor[intakeR] = motor[intakeL] = val;
}

void intakeCone(){
	SensorValue(coneIntake) = !SensorValue(coneIntake);
}

void drive(int rVal, int lVal){
	motor[rightDrive1] = motor[rightDrive2] = rVal;
	motor[leftDrive1] = motor[leftDrive2] = lVal;
}

void driveDeadband(int rVal, int lVal, int db = 10){
	if(deadband(rVal, 0, db))
		motor[rightDrive1] = motor[rightDrive2] = rVal;
	else
		motor[rightDrive1] = motor[rightDrive2] = 0;
	if(deadband(lVal, 0, db))
		motor[leftDrive1] = motor[leftDrive2] = lVal;
	else
		motor[leftDrive1] = motor[leftDrive2] = 0;
}

task driveControl(){
	while(true){
		driveDeadband(vexRT[Ch2], vexRT[Ch3], 10);
		delay(5);
	}
}

void mobileGoalIntake(){
	intake(127);
	while(SensorValue(intakeEncoder) < 2000){
		delay(5);
	}
	intake(25);
	while(SensorValue(intakeEncoder) < 3350){
		delay(5);
	}
	intake(0);
	mobileGoal = true;
}

void mobileGoalOuttake(){
	intake(-127);
	while(SensorValue(intakeEncoder) > 2000){
		delay(5);
	}
	intake(-25);
	while(SensorValue(intakeEncoder) > 900){
		delay(5);
	}
	intake(0);
	mobileGoal = false;
}

task stage1Control(){
    float old = SensorValue(stage1Encoder);
    desiredStage1 = SensorValue(stage1Encoder);
    float kP1 = 0.65;
    float kI1 = 0.0001;
    float kD1 = 0.02;
    float error = 0;
    float integral = 0;
    float derivative = 0;
    while(true){
        error = desiredStage1 - SensorValue(stage1Encoder);
        integral = integral + error;
        if(error == 0 || !stage1Change){
            integral = 0;
        }
        if(abs(error)>200){
            integral = 0;
        }
        if(desiredStage1 == SensorValue(stage1Encoder)){
            stage1Change = false;
        }
        derivative = error - old;
        old = SensorValue(stage1Encoder);
        towerStage1(limit(error * kP1 + integral * kI1 + derivative * kD1));
        delay(5);
    }
}

task stage2Control(){
    desiredStage2 = SensorValue(stage2Encoder);
    float kP2 = 0.09;
    float error = 0;
    while(true){
        error = desiredStage2 - SensorValue(stage2Encoder);
        towerStage2(limit(error * kP2));
        delay(5);
    }
}

void normalStackCone(int cone){
    if(cone == 1){
        desiredStage1 = -970;
        wait1Msec(500);
        desiredStage2 = 100 + stage2Limit;
    }
    else if(cone == 2){
        desiredStage1 = -1055;
        wait1Msec(650);
        desiredStage2 = 165 + stage2Limit;
    }
    else if(cone == 3){
        desiredStage1 = -1130;
        wait1Msec(600);
        desiredStage2 = 240 + stage2Limit;
        //wait1Msec(400);
        //desiredStage2 = 175 + stage2Limit;
    }
    else if(cone == 4){
        desiredStage1 = -1220;
        wait1Msec(500);
        desiredStage2 = 425 + stage2Limit;
        wait1Msec(600);
        desiredStage2 = 300 + stage2Limit;
	}
    else if(cone == 5){
        desiredStage1 = -1245;
        wait1Msec(550);
        desiredStage2 = 530 + stage2Limit;
        wait1Msec(700);
        desiredStage2 = 400 + stage2Limit;
    }
    else if(cone == 6){
        desiredStage1 = -1247;
        wait1Msec(600);
        desiredStage2 = 700 + stage2Limit;
        wait1Msec(700);
        desiredStage2 = 500 + stage2Limit;
    }
    else if(cone == 7){
        desiredStage1 = -1240;
        wait1Msec(650);
        desiredStage2 = 830 + stage2Limit;
        wait1Msec(700);
        desiredStage2 = 680 + stage2Limit;
    }
    else if(cone == 8){
        desiredStage1 = -1235;
        desiredStage2 = 960 + stage2Limit;
        wait1Msec(700);
        desiredStage2 = 1005 + stage2Limit;
        wait1Msec(800);
        desiredStage2 = 800 + stage2Limit;
    }
    else if(cone == 9){
        desiredStage1 = -1200;
        //desiredStage2 = 1000 + stage2Limit;
        //wait1Msec(850);
        desiredStage2 = 1240 + stage2Limit;
        wait1Msec(1300);
        desiredStage2 = 1000 + stage2Limit;
    }
    else if(cone == 10){
        desiredStage1 = -1200;
        desiredStage2 = 1400 + stage2Limit;
        wait1Msec(1300);
        desiredStage2 = 1250 + stage2Limit;
    }
    else if(cone == 11){
        desiredStage1 = -1150;
        desiredStage2 = 1580 + stage2Limit;
        wait1Msec(750);
        desiredStage2 = 1550 + stage2Limit;
        wait1Msec(1000);
        desiredStage2 = 1380 + stage2Limit;
    }
    else if(cone == 12){
        desiredStage1 = -1100;
        desiredStage2 = 1900 + stage2Limit;
        wait1Msec(1500);
        desiredStage2 = 1500 + stage2Limit;
    }
}

void normalStackConeNoWait(int cone){
    if(cone == 1){
        desiredStage1 = -970;
        desiredStage2 = 100 + stage2Limit;
    }
    else if(cone == 2){
        desiredStage1 = -1055;
        desiredStage2 = 165 + stage2Limit;
    }
    else if(cone == 3){
        desiredStage1 = -1130;
        desiredStage2 = 240 + stage2Limit;
    }
    else if(cone == 4){
        desiredStage1 = -1220;
        desiredStage2 = 300 + stage2Limit;
	}
    else if(cone == 5){
        desiredStage1 = -1245;
        desiredStage2 = 400 + stage2Limit;
    }
    else if(cone == 6){
        desiredStage1 = -1247;
        desiredStage2 = 500 + stage2Limit;
    }
    else if(cone == 7){
        desiredStage1 = -1240;
        desiredStage2 = 680 + stage2Limit;
    }
    else if(cone == 8){
        desiredStage1 = -1235;
        desiredStage2 = 800 + stage2Limit;
    }
    else if(cone == 9){
        desiredStage1 = -1200;
        desiredStage2 = 1000 + stage2Limit;
    }
    else if(cone == 10){
        desiredStage1 = -1200;
        desiredStage2 = 1250 + stage2Limit;
    }
    else if(cone == 11){
        desiredStage1 = -1150;
        desiredStage2 = 1380 + stage2Limit;
    }
    else if(cone == 12){
        desiredStage1 = -1100;
        desiredStage2 = 1500 + stage2Limit;
    }
}

void highStackCone(int cone){
    if(cone == 1){
        desiredStage1 = -1040;
        desiredStage2 = 1030 + stage2Limit;
    }
    else if(cone == 2){
        desiredStage1 = -1070;
        desiredStage2 = 1270 + stage2Limit;
    }
    else if(cone == 3){
        desiredStage1 = -1050;
        desiredStage2 = 1350 + stage2Limit;
    }
    else if(cone == 4){
        desiredStage1 = -1015;
        desiredStage2 = 1555 + stage2Limit;
    }
    else if(cone == 5){
        desiredStage1 = -970;
        desiredStage2 = 1990 + stage2Limit;
    }
    else if(cone == 6){
        desiredStage1 = -925;
        desiredStage2 = 2230 + stage2Limit;
    }
    else if(cone == 7){
        desiredStage1 = -825;
        desiredStage2 = 2595 + stage2Limit;
    }
}

void groundPickUpCone(int stack){
    if(stack == 7){
        desiredStage2 = 1400 + stage2Limit;
        wait1Msec(300);
    }
    else if(stack == 8){
        desiredStage2 = 1600 + stage2Limit;
        wait1Msec(300);
    }
    else if(stack == 9){
        desiredStage2 = 1750 + stage2Limit;
        wait1Msec(300);
    }
    else if(stack >= 10){
        desiredStage2 = 2900 + stage2Limit;
        wait1Msec(300);
        desiredStage1 = -495;
        wait1Msec(400);
    }
    desiredStage1 = -500;
    desiredStage2 = 1050 + stage2Limit;
}

void lowGroundPickUpCone(){
    desiredStage1 = -435;
    desiredStage2 = 1030 + stage2Limit;
}

void preloadPickUpCone(){
    desiredStage1 = -810;
    desiredStage2 = 620 + stage2Limit;
}
 
void setupLift(){
    desiredStage1 = -770;
    wait1Msec(900);
    stage2Limit = SensorValue(stage2Encoder);
    desiredStage2 = 800 + stage2Limit;
    wait1Msec(900);
    groundPickUpCone(1);
}

task coneControl(){
	currentConeStack = 0;
	//currentHighConeStack = 0;
	currentConeStack = 0 + autonCompleted;
	bool tippedCone = false;
	bool intakeLowered = false;
	highGoal = false;
	bool highGoalAccurate = false;
	bool messUpButton = false;
	bool incButton = false;
	bool ripButton = false;
	bool intakeUp = false;
	while(true){
		if(!highGoal){
			if(vexRT[Btn7R]){
				currentConeStack = 0;
			}
			if(vexRT[Btn6D] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentConeStack > 0){
					currentConeStack--;
					if(intakeUp)
						normalStackConeNoWait(currentConeStack);
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentConeStack < 12){
					currentConeStack++;
					if(intakeUp)
						normalStackConeNoWait(currentConeStack);
				}
			}
			if(vexRT[Btn6U] != ripButton){
				ripButton = !ripButton;
				if(currentConeStack < 13 && ripButton){
					currentConeStack++;
					normalStackCone(currentConeStack);
					stage1Change = true;
					intakeLowered = true;
					intakeUp = true;
				}
			}
			if(vexRT[Btn5D] != tippedCone){
				tippedCone = !tippedCone;
				if(tippedCone){
					intakeUp = false;
					if(intakeLowered){
						groundPickUpCone(currentConeStack);
						stage1Change = true;
						intakeLowered = false;
					}
					else{
						lowGroundPickUpCone();
						stage1Change = true;
						intakeLowered = true;
					}
				}
			}
		}
		if(highGoal){
			if(vexRT[Btn7R]){
				currentHighConeStack = 0;
			}
			if(vexRT[Btn6D] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentHighConeStack > 0){
					currentHighConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentHighConeStack < 7){
					currentHighConeStack++;
				}
			}
			if(vexRT[Btn6U] != ripButton){
				ripButton = !ripButton;
				if(currentHighConeStack < 7 && ripButton){
					currentHighConeStack++;
					highStackCone(currentHighConeStack);
					stage1Change = true;
					intakeLowered = true;
					intakeUp = true;
				}
			}
			if(vexRT[Btn5D] != tippedCone){
				tippedCone = !tippedCone;
				if(tippedCone){
					intakeUp = false;
					if(intakeLowered){
						groundPickUpCone(1);
						stage1Change = true;
						intakeLowered = false;
					}
					else{
						lowGroundPickUpCone();
						stage1Change = true;
						intakeLowered = true;
					}
				}
			}
		}
		if(vexRT[Btn7L] != highGoalAccurate){
			highGoalAccurate = !highGoalAccurate;
			if(highGoalAccurate){
				highGoal = !highGoal;
				SensorValue(highGoalLight) = highGoal;
			}
		}
		if(vexRT[Btn8L])
			preloadPickUpCone();
	}
}


task intakeControl(){
	bool accurate = false;
	bool bAccurate = false;
	while(true){
		if(vexRT[Btn7D] != accurate){
			accurate = !accurate;
			if(accurate){
				if(mobileGoal)
					mobileGoalOuttake();
				else
					mobileGoalIntake();
			}
			delay(5);
		}
		if(vexRT[Btn8R] != bAccurate){
			bAccurate = !bAccurate;
			if(bAccurate){
				desiredStage1 = -1000;
				desiredStage2 = 2900 + stage2Limit;
			}
			delay(5);
		}
	}
}

void pre_auton() {
	wait1Msec(100);
}

task autonomous(){
	SensorValue[stage1Encoder] = 0;
	startTask(stage1Control);
	startTask(stage2Control);
	setupLift();
	drive(127, 127);
	wait1Msec(1000); \\CAM, THIS IS THE VALUE THAT YOU WANT TO TOY WITH
	highStackCone(1);
	wait1Msec(2000); \\CAM, THIS IS THE VALUE THAT YOU WANT TO TOY WITH
	drive(-20, -20);
	wait1Msec(200);
	drive(0, 0);
	wait1Msec(200);
	intakeCone();
	wait1Msec(400);
	\\THIS STUFF INCLUDES BACKING UP AND RETURNING TO GROUND HEIGHT (NOT NEEDED)
	\\drive(-50, -50);
	\\wait1Msec(600);
	\\drive(20, 20);
	\\wait1Msec(200);
	\\drive(0, 0);
	\\groundPickUpCone(1);
	autonCompleted = true;
	currentHighConeStack = 1;
}

task usercontrol(){
	startTask(coneControl);
	startTask(driveControl);
	startTask(stage1Control);
	startTask(stage2Control);
	startTask(intakeControl);
	if(!autonCompleted){
		SensorValue[stage1Encoder] = 0;
		setupLift();
	}
	autonCompleted = false;
	bool accurate = false;
	while(true){
		if(vexRT[Btn5U] != accurate){
			accurate = !accurate;
			if (accurate)
				intakeCone();
		}
	}
}
