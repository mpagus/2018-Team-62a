#pragma config(Sensor, in1,    intakeEncoder,  sensorPotentiometer)
#pragma config(Sensor, dgtl2,  highGoalLight,  sensorDigitalOut)
#pragma config(Sensor, dgtl3,  stage2Encoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, stage1Encoder,  sensorQuadEncoder)
#pragma config(Motor,  port1,           leftDrive2,    tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightDrive1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intakeMotor,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           leftDrive1,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           rightDrive2,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           rightDrive3,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           stage2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           stage1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           sideRollerMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftDrive3,    tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

float desiredStage1 = 0;
float desiredStage2 = 0;
float desiredLeft = 0;
float desiredRight = 0;
bool mobileGoal = true;
bool stage1Reset = true;
bool highGoal = false;
int currentConeStack = 0;
int currentHighConeStack = 0;
bool autonRan = false;
float stage2Scalar = 390;

int limit(int val, int min = -127, int max = 127){
	if(val>max){
		return max;
	}
	if(val<min){
		return min;
	}
	return val;
}

bool deadband(int val, int target, int db = 10){
	return val > target + db || val < target - db;
}

bool deadband2(int val, int target, int db){
	return abs(val-target) < db;
}

void towerStage1(int val){
	motor[stage1] = val;
}

void towerStage2(int val){
	motor[stage2] = val;
}

void intake(int val){
	motor[intakeMotor] = val;
}

void sideRoller(int val){
	motor[sideRollerMotor] = val;
}

void drive(int rVal, int lVal){
	motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = rVal;
	motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = lVal;
}

void driveDeadband(int rVal, int lVal, int db = 10){
	if(deadband(rVal, 0, db))
		motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = rVal;
	else
		motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = 0;
	if(deadband(lVal, 0, db))
		motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = lVal;
	else
		motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = 0;
}

task driveControl(){
	while(true){
		driveDeadband(vexRT[Ch2], vexRT[Ch3], 10);
		delay(5);
	}
}

task mobileGoalMotors(){
	bool accurate = false;
	while(true){
		if(!mobileGoal){
			if(SensorValue(intakeEncoder) < 2150)
				intake(127);
			else
				intake(10);
		}
		else{
			if(SensorValue(intakeEncoder) > 1300)
				intake(-127);
			else if(SensorValue(intakeEncoder) > 750)
				intake(-30);
			else
				intake(-10);
		}
		if(vexRT[Btn7U] != accurate){
			accurate = !accurate;
			if(accurate)
				mobileGoal = !mobileGoal;
		}
		delay(5);
	}
}

task mobileGoalAuton(){
	while(true){
		if(!mobileGoal){
			if(SensorValue(intakeEncoder) < 2050)
				intake(127);
			else
				intake(2);
		}
		else{
			if(SensorValue(intakeEncoder) > 1300)
				intake(-127);
			else if(SensorValue(intakeEncoder) > 750)
				intake(-30);
			else
				intake(-10);
		}
		delay(5);
	}
}

task stage1Control(){
	float old = SensorValue(stage1Encoder);
	desiredStage1 = SensorValue(stage1Encoder);
	float kP1 = 0.8;
	float kI1 = 0;
	float kD1 = 0.07;
	float error = 0;
	float integral = 0;
	float derivative = 0;
	while(true){
		error = desiredStage1 - SensorValue(stage1Encoder);
		integral = integral + error;
		if(deadband(error, 0, 20) || stage1Reset){
			integral = 0;
			stage1Reset = true;
		}
		if(abs(error)>200){
			integral = 0;
		}
		derivative = error - old;
		old = SensorValue(stage1Encoder);
		towerStage1(limit(error * kP1 + integral * kI1 + derivative * kD1));
		delay(5);
	}
}

task stage2Control(){
	desiredStage2 = (SensorValue(stage2Encoder) - stage2Scalar);
	float kP2 = 0.4;
	float error = 0;
	while(true){
		error = desiredStage2 - (SensorValue(stage2Encoder) - stage2Scalar);
		towerStage2(limit(error * kP2));
		delay(5);
	}
}

task drivebaseControl(){
	desiredRight = SensorValue(rightEncoder);
	desiredLeft = SensorValue(leftEncoder);
	float kP3 = 0.5;
	float errorR = 0;
	float errorL = 0;
	while(true){
		errorR = desiredRight - SensorValue(rightEncoder);
		errorL = desiredLeft - SensorValue(leftEncoder);
		drive(limit(-1 * kP3 * errorR), limit(-1 * kP3  * errorL));
		delay(5);
	}
}

void moveStage1WaitUntil(float desiredValue, float continueValue){
	desiredStage1 = desiredValue;
	while(!deadband2(SensorValue(stage1Encoder), continueValue, 40)){
		wait1Msec(20);
	}
}

void moveStage1Wait(float desiredValue){
	moveStage1WaitUntil(desiredValue, desiredValue);
}

void moveStage2WaitUntil(float desiredValue, float continueValue){
	desiredStage2 = desiredValue;
	while(!deadband2(SensorValue(stage2Encoder) - stage2Scalar, continueValue, 40)){
		wait1Msec(20);
	}
}

void moveStage2Wait(float desiredValue){
	moveStage2WaitUntil(desiredValue, desiredValue);
}

void moveBothStagesWait(float desiredValue1, float desiredValue2){
	desiredStage1 = desiredValue1;
	desiredStage2 = desiredValue2;
	while(!deadband2(SensorValue(stage1Encoder), desiredValue1, 70) || !deadband2(SensorValue(stage2Encoder) - stage2Scalar, desiredValue2, 70)){
		wait1Msec(20);
	}
}

void moveBothStagesWaitDB(float desiredValue1, float desiredValue2, int deadbands){
	desiredStage1 = desiredValue1;
	desiredStage2 = desiredValue2;
	while(!deadband2(SensorValue(stage1Encoder), desiredValue1, deadbands) || !deadband2(SensorValue(stage2Encoder) - stage2Scalar, desiredValue2, deadbands)){
		wait1Msec(20);
	}
}

void driveBoth(int value){
	desiredLeft = desiredLeft + value;
	desiredRight = desiredRight + value;
}

void driveBothWaitUntil(int value, int continueValue){
	desiredLeft = desiredLeft + value;
	desiredRight = desiredRight + value;
	while(!deadband2(SensorValue(leftEncoder), desiredLeft - value + continueValue, 40) || !deadband2(SensorValue(rightEncoder), desiredRight - value + continueValue, 40)){
		wait1Msec(20);
	}
}

void driveBothWait(int value){
	driveBothWaitUntil(value, value);
}

void driveSides(int valueR, int valueL){
	desiredLeft = desiredLeft + valueL;
	desiredRight = desiredRight + valueR;
}

void driveSidesWait(int valueR, int valueL){
	desiredLeft = desiredLeft + valueL;
	desiredRight = desiredRight + valueR;
	while(!deadband2(SensorValue(leftEncoder), desiredLeft, 40) || !deadband2(SensorValue(rightEncoder), desiredRight, 40)){
		wait1Msec(20);
	}
}

void groundPickUpCone(){
	desiredStage1 = 25;
	desiredStage2 = 45;
}

void groundPickUpConeWait(){
	moveBothStagesWait(30, 45);
}

void groundSetUpCone(){
	desiredStage1 = -250;
	desiredStage2 = 0;
}

void groundSetUpConeWait(){
	moveBothStagesWait(-225, 0);
}

void groundSetUpConeOutWait(){
	moveStage2Wait(95);
	moveBothStagesWait(-225, 45);
	moveStage2Wait(0);
}

void preloadPickUpCone(){
	desiredStage1 = -205;
	desiredStage2 = 213;
}

void preloadSetUpCone(){
	desiredStage1 = -380;
	desiredStage2 = 208;
}

float stage1FormulaLow(float inches){
	return -1.0238*inches*inches + 4.7619*inches - 122.9;
}

float stage2FormulaLow(float inches){
	return 2.1545*inches*inches - 56.235*inches + 165.54;
}

float stage1FormulaHigh(float inches){
	return 0.3578*inches*inches - 46.858*inches + 901.2;
}

float stage2FormulaHigh(float inches){
	return 0.0653*inches*inches*inches - 7.7486*inches*inches + 291.82*inches - 2470.5;
}

void normalStackCone(int cone){
	//cone1
	if(cone == 1){
		moveStage1WaitUntil(stage1FormulaLow(19.25) - 20, -150);
		moveBothStagesWait(stage1FormulaLow(19.25) - 20, stage2FormulaLow(19.25) + 65);
		moveBothStagesWait(stage1FormulaLow(11), stage2FormulaLow(11) + 70);
	}
	//cone2
	else if(cone == 2){
		moveStage1WaitUntil(stage1FormulaLow(21.75), -200);
		moveBothStagesWait(stage1FormulaLow(21.75), stage2FormulaLow(21.75) + 125);
		moveBothStagesWait(stage1FormulaLow(13.5), stage2FormulaLow(13.5) + 120);
	}
	//cone3
	else if(cone == 3){
		moveStage1WaitUntil(stage1FormulaLow(23.5) + 10, -250);
		moveBothStagesWait(stage1FormulaLow(23.5) + 10, stage2FormulaLow(23.5) + 100);
		moveBothStagesWait(stage1FormulaLow(16), stage2FormulaLow(16) + 95);
		desiredStage2 = 50;
		wait1Msec(100);
	}
	//cone4
	else if(cone == 4){
		moveStage1WaitUntil(stage1FormulaLow(25), -300);
		moveBothStagesWait(stage1FormulaLow(25), stage2FormulaLow(25) + 90);
		moveBothStagesWait(stage1FormulaLow(19), stage2FormulaLow(19) + 95);
		desiredStage2 = 50;
		wait1Msec(100);
	}
	//cone5
	else if(cone == 5){
		moveStage1WaitUntil(-650, -400);
		moveBothStagesWait(-630, 235);
		moveBothStagesWait(-620, 50);
		desiredStage1 = -850;
		wait1Msec(650);
		moveBothStagesWait(-630, 25);
		moveStage1Wait(-450);
		desiredStage2 = 60;
		wait1Msec(100);
	}
	//cone6
	else if(cone == 6){
		moveStage1WaitUntil(stage1FormulaHigh(35.5), -175);
		moveBothStagesWait(stage1FormulaHigh(31.75), stage2FormulaHigh(31.75) - 100);
		moveBothStagesWait(stage1FormulaHigh(23.5) + 35, stage2FormulaHigh(23.5) - 95);
		desiredStage1 = 10;
		wait1Msec(130);
		groundSetUpCone();
		desiredStage1 = 10;
		wait1Msec(340);
	}
	//cone7
	else if(cone == 7){
		moveStage1WaitUntil(stage1FormulaHigh(35.5) + 15, -135);
		moveBothStagesWait(stage1FormulaHigh(34.75) + 15, stage2FormulaHigh(34.25) - 135);
		moveBothStagesWait(stage1FormulaHigh(26), stage2FormulaHigh(26) - 125);
		groundSetUpCone();
		desiredStage1 = stage1FormulaHigh(26);
		wait1Msec(200);
	}
	//cone8
	else if(cone == 8){
		moveStage1WaitUntil(stage1FormulaHigh(36.75) + 5, -225);
		moveBothStagesWait(stage1FormulaHigh(36.75) + 5, stage2FormulaHigh(36.75) - 110);
		moveBothStagesWait(stage1FormulaHigh(28.5), stage2FormulaHigh(28.5) - 120);
		groundSetUpCone();
		desiredStage1 = stage1FormulaHigh(28.5) + 20;
		wait1Msec(250);
	}
	//cone9
	else if(cone == 9){
		moveStage1WaitUntil(stage1FormulaHigh(39.25) - 35, -325);
		moveBothStagesWait(stage1FormulaHigh(39.25) - 35, stage2FormulaHigh(39.25) - 115);
		moveBothStagesWait(stage1FormulaHigh(31) - 30, stage2FormulaHigh(31) - 110);
		groundSetUpCone();
		desiredStage1 = stage1FormulaHigh(31) + 10;
		wait1Msec(200);
	}
	//cone10
	else if(cone == 10){
		moveStage1WaitUntil(stage1FormulaHigh(41.75) - 30, -400);
		moveBothStagesWait(stage1FormulaHigh(41.75) - 25, stage2FormulaHigh(41.75) - 100);
		moveBothStagesWait(stage1FormulaHigh(33.5) + 10, stage2FormulaHigh(33.5) - 95);
	}
	//cone11
	else if(cone == 11){
		moveStage1WaitUntil(stage1FormulaHigh(44.25) - 35, -400);
		moveBothStagesWait(stage1FormulaHigh(44.25) - 30, stage2FormulaHigh(44.25) - 105);
		moveBothStagesWait(stage1FormulaHigh(36), stage2FormulaHigh(36) - 100);
	}
	//cone12
	else if(cone == 12){
		moveStage1WaitUntil(-660, -375);
		moveStage2WaitUntil(700, 635);
		wait1Msec(50);
		moveStage2WaitUntil(825, 775);
		wait1Msec(50);
		moveStage1Wait(-615);
		wait1Msec(50);
		moveBothStagesWait(-435, 940);
		wait1Msec(50);
		moveBothStagesWait(-350, 960);
	 	moveStage1Wait(-410);
	 	wait1Msec(200);
	}
	groundSetUpConeWait();
}

void getOutOfTheWay(){
	moveStage1WaitUntil(-640, -375);
	desiredStage2 = 900;
}

void getOutOfTheWayMid(){
	moveStage1WaitUntil(-640, -375);
	desiredStage2 = 160;
}

float stage1FormulaHighGoal(float inches){
	return 1.0265*inches*inches - 44.529*inches - 122.82;
}

float stage2FormulaHighGoal(float inches){
	return 0.5676*inches*inches + 3.1869*inches + 91.881;
}

//coneH
void highStackCone(float cone){
	if(cone==6){
		moveBothStagesWaitDB(stage1FormulaHighGoal(18 + 2.5*cone) - 5, stage2FormulaHighGoal(18 + 2.5*cone) + 15, 80);
	}
	else{
		moveBothStagesWaitDB(stage1FormulaHighGoal(19 + 2.5*cone), stage2FormulaHighGoal(16 + 2.5*cone), 85);
	}
}

//coneD
void highStackDetach(int cone){
	moveBothStagesWait(stage1FormulaHighGoal(10.2 + 2.5*cone), stage2FormulaHighGoal(10.2 + 2.5*cone));
	wait1Msec(350);
	moveBothStagesWait(-250, 460);
}

task coneControl(){
	currentConeStack = 0;
	currentHighConeStack = 0;
	bool pickUpCone = false;
	highGoal = false;
	bool highGoalAccurate = false;
	bool messUpButton = false;
	bool incButton = false;
	bool ripButton = false;
	bool highGoalDetach = false;
	bool coneButton = false;
	bool intakeLowered = true;
	while(true){
		if(!highGoal){
			if(vexRT[Btn8R]){
				currentConeStack = 0;
			}
			if(vexRT[Btn8D] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentConeStack > 0){
					currentConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentConeStack < 11){
					currentConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					currentConeStack++;
					normalStackCone(currentConeStack);
					stage1Reset = true;
					intakeLowered = true;
				}
			}
			if(vexRT[Btn6D] != coneButton){
				coneButton = !coneButton;
				if(coneButton){
					if(intakeLowered){
						groundPickUpConeWait();
						intakeLowered = false;
					}
					else{
						groundSetUpConeOutWait();
						intakeLowered = true;
					}
				}
			}

		}
		if(highGoal){
			if(vexRT[Btn8R]){
				currentHighConeStack = 0;
			}
			if(vexRT[Btn8D] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentHighConeStack > 0){
					currentHighConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentHighConeStack < 7){
					currentHighConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					if(highGoalDetach){
						highGoalDetach = false;
						highStackDetach(currentHighConeStack);
					}
					else if(currentHighConeStack < 7){
						currentHighConeStack++;
						highStackCone(currentHighConeStack);
						highGoalDetach = true;
						intakeLowered = true;
					}
				}
			}
			if(vexRT[Btn6D] != coneButton){
				coneButton = !coneButton;
				if(coneButton){
					if(intakeLowered){
						groundPickUpConeWait();
						intakeLowered = false;
					}
					else{
						groundSetUpConeOutWait();
						intakeLowered = true;
					}
				}
			}
		}
		//if(vexRT[Btn7D] != highGoalAccurate){
		//	highGoalAccurate = !highGoalAccurate;
		//	if(highGoalAccurate){
		//		highGoal = !highGoal;
		//		SensorValue(highGoalLight) = highGoal;
		//	}
		//}
		if(vexRT[Btn8L]){
			getOutOfTheWay();
			intakeLowered = false;
		}
		if(vexRT[Btn7R]){
			getOutOfTheWayMid();
			intakeLowered = false;
		}
		delay(5);
	}
}

task sideRollers(){
	while(true){
		if(vexRT[Btn5U]){
			sideRoller(127);
		}
		else if(vexRT[Btn5D]){
			sideRoller(-127);
		}
		else{
			sideRoller(0);
		}
		delay(10);
	}
}

void unfoldRobot(){
	moveStage1Wait(-300);
	moveStage2Wait(0);
	groundSetUpConeWait();
}

void unfoldRobotAuton(){
	moveStage1Wait(-400);
	//moveStage2Wait(0);
	wait1Msec(500);
	highStackCone(1.55);
	wait1Msec(500);
}

void turn90DegreesR(){
	driveSidesWait(295,-295);
}

void turn90DegreesL(){
	driveSidesWait(-295,295);
}

void turn45DegreesR(){
	driveSidesWait(150,-150);
}

void turn45DegreesL(){
	driveSidesWait(-150,150);
}

void pre_auton() {}

void simpleAuton(){
	autonRan = true;
	SensorValue(highGoalLight)=1;
	SensorValue(stage1Encoder) = 0;
	SensorValue(stage2Encoder) = 0;
	startTask(stage1Control);
	startTask(stage2Control);
	unfoldRobotAuton();
	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;
	startTask(drivebaseControl);
	startTask(mobileGoalAuton);
	driveBothWait(-650);
	wait1Msec(500);
	highStackDetach(1);
	wait1Msec(400);
	turn90DegreesR();
	//wait1Msec(400);
	//driveBothWait(-450);
}

void auton(){
	autonRan = true;
	SensorValue(highGoalLight)=1;
	SensorValue(stage1Encoder) = 0;
	SensorValue(stage2Encoder) = 0;
	startTask(stage1Control);
	startTask(stage2Control);
	unfoldRobotAuton();
	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;
	startTask(drivebaseControl);
	startTask(mobileGoalAuton);
	wait1Msec(50);
	driveBothWaitUntil(-500, -300);
	mobileGoal = false;
	wait1Msec(500);
	mobileGoal = true;
	wait1Msec(500);
	driveBoth(250);
	normalStackCone(1);
	desiredStage1 = -500;
	desiredStage2 = 0;
	driveBothWait(500);
	turn90DegreesL();
	turn45DegreesL();
	driveBothWait(500);
	turn90DegreesL();
	driveBothWait(500);
	mobileGoal = false;
}

task autonomous(){
	simpleAuton();
	//auton();
}

task usercontrol(){
	SensorValue(highGoalLight)=1;
	startTask(coneControl);
	startTask(driveControl);
	startTask(mobileGoalMotors);
	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;
	if(!autonRan){
		SensorValue(stage1Encoder) = 0;
		SensorValue(stage2Encoder) = 0;
		//wait1Msec(50);
		startTask(stage1Control);
		startTask(stage2Control);
		//wait1Msec(50);
		unfoldRobot();
	}
	else{
		startTask(stage1Control);
		startTask(stage2Control);
		autonRan = false;
		groundSetUpConeWait();
	}
	// while(true){
	// 	if(vexRT[Btn7R]){
	// 		SensorValue(stage2Encoder) = 0;
	// 		startTask(stage1Control);
	// 		startTask(stage2Control);
	// 	}
	// 	if(vexRT[Btn8D]) {
	// 		groundPickUpCone();
	// 		preloadPickUpCone();
	// 	}
	// 	if(vexRT[Btn8U]) {
	// 		groundSetUpCone();
	// 		//preloadSetUpCone();
	// 	}
	// 	if(vexRT[Btn7D]) {
	// 		cone--;
	// 		while(vexRT[Btn7D]){
	// 			delay(5);
	// 		}
	// 	}
	// 	if(vexRT[Btn7U]){
	// 		normalStackCone(cone);
	// 		cone++;
	// 	}
	// 	if(vexRT[Btn7L]){
	// 		cone=0;
	// 	}
	// }
	// while(true){
	// 	if(vexRT[Btn7R]){
	// 		SensorValue(stage2Encoder) = 0;
	// 		startTask(stage1Control);
	// 		startTask(stage2Control);
	// 	}
	// 	if(vexRT[Btn8D])
	// 		groundPickUpCone();
	// 	if(vexRT[Btn8U])
	// 		groundSetUpCone();
	// 	if(vexRT[Btn7D]){
	// 		cone++;
	// 		while(vexRT[Btn7D]){
	// 			delay(5);
	// 		}
	// 		wait1Msec(100);
	// 	}
	// 	if(vexRT[Btn7U]){
	// 		highStackCone(cone);
	// 	}
	// 	if(vexRT[Btn7L]){
	// 		highStackDetach(cone);
	// 	}
	// }
}
