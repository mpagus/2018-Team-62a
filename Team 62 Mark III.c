#pragma config(Sensor, in1,    intakeEncoder,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  highGoalLight,  sensorDigitalOut)
#pragma config(Sensor, dgtl9,  stage1Encoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl11, stage2Encoder,  sensorQuadEncoder)
#pragma config(Motor,  port1,           leftDrive2,    tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightDrive1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intakeMotor,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           leftDrive1,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           rightDrive2,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           rightDrive3,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           stage2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           stage1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           sideRollerMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftDrive3,    tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

float desiredStage1 = 0;
float desiredStage2 = 0;
bool mobileGoal = true;
bool stage1Change = true;
bool highGoal = false;
int currentConeStack = 0;
int currentHighConeStack = 0;

int limit(int val, int min = -127, int max = 127){
	if(val>max){
		return max;
	}
	if(val<min){
		return min;
	}
	return val;
}

bool deadband(int val, int target, int db = 10){
	return val > target + db || val < -target - db;
}

void towerStage1(int val){
	motor[stage1] = val;
}

void towerStage2(int val){
	motor[stage2] = val;
}

void intake(int val){
	motor[intakeMotor] = val;
}

void sideRoller(int val){
	motor[sideRollerMotor] = val;
}

void drive(int rVal, int lVal){
	motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = rVal;
	motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = lVal;
}

void driveDeadband(int rVal, int lVal, int db = 10){
	if(deadband(rVal, 0, db))
		motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = rVal;
	else
		motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = 0;
	if(deadband(lVal, 0, db))
		motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = lVal;
	else
		motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = 0;
}

task driveControl(){
	while(true){
		driveDeadband(vexRT[Ch2], vexRT[Ch3], 10);
		delay(5);
	}
}

task mobileGoalMotors(){
	bool accurate = false;
	while(true){
		if(!mobileGoal){
			if(SensorValue(intakeEncoder) < 2150)
				intake(127);
			else
				intake(10);
		}
		else{
			if(SensorValue(intakeEncoder) > 1300)
				intake(-127);
			else if(SensorValue(intakeEncoder) > 750)
				intake(-30);
			else
				intake(-10);
		}
		if(vexRT[Btn7L] != accurate){
			accurate = !accurate;
			if(accurate)
				mobileGoal = !mobileGoal;
		}
		delay(5);
	}
}

task stage1Control(){
	float old = SensorValue(stage1Encoder);
	desiredStage1 = SensorValue(stage1Encoder);
	float kP1 = 0.8;
	float kI1 = 0;
	float kD1 = 0.1;
	float error = 0;
	float integral = 0;
	float derivative = 0;
	while(true){
		error = desiredStage1 - SensorValue(stage1Encoder);
		integral = integral + error;
		if(error == 0 || !stage1Change){
			integral = 0;
		}
		if(abs(error)>200){
			integral = 0;
		}
		if(desiredStage1 == SensorValue(stage1Encoder)){
			stage1Change = false;
		}
		derivative = error - old;
		old = SensorValue(stage1Encoder);
		towerStage1(limit(error * kP1 + integral * kI1 + derivative * kD1));
		delay(5);
	}
}

task stage2Control(){
	desiredStage2 = SensorValue(stage2Encoder);
	float kP2 = 0.4;
	float error = 0;
	while(true){
		error = desiredStage2 - SensorValue(stage2Encoder);
		towerStage2(limit(error * kP2));
		delay(5);
	}
}

void groundPickUpCone(){
	desiredStage1 = -8
	desiredStage2 = 53;
}

void groundSetUpCone(){
	desiredStage1 = -225;
	desiredStage2 = 30;
}

void preloadPickUpCone(){
	desiredStage1 = -205;
	desiredStage2 = 213;
}

void preloadSetUpCone(){
	desiredStage1 = -380;
	desiredStage2 = 208;
}

float stage1FormulaLow(float inches){
	return -1.0238*inches*inches + 4.7619*inches - 117.9;
}

float stage2FormulaLow(float inches){
	return 2.1545*inches*inches - 56.235*inches + 160.54;
}

float stage1FormulaHigh(float inches){
	return 0.3578*inches*inches - 46.858*inches + 896.2;
}

float stage2FormulaHigh(float inches){
	return 0.0653*inches*inches*inches - 7.7486*inches*inches + 291.82*inches - 2466.5;
}

void normalStackCone(int cone){
	//cone1
	if(cone == 1){
		desiredStage1 = stage1FormulaLow(19.25);
		wait1Msec(225);
		desiredStage2 = stage2FormulaLow(19.25);
		wait1Msec(410);
		desiredStage1 = stage1FormulaLow(11);
		desiredStage2 = stage2FormulaLow(11);
		wait1Msec(250);
	}
	//cone2
	else if(cone == 2){
		desiredStage1 = stage1FormulaLow(21.75)-10;
		wait1Msec(300);
		desiredStage2 = stage2FormulaLow(21.75)+35;
		wait1Msec(350);
		desiredStage1 = stage1FormulaLow(13.5)-10;
		desiredStage2 = stage2FormulaLow(13.5)+40;
		wait1Msec(315);
	}
	//cone3
	else if(cone == 3){
		desiredStage1 = stage1FormulaLow(23.5)-40;
		wait1Msec(350);
		desiredStage2 = stage2FormulaLow(23.5)+65;
		wait1Msec(440);
		desiredStage1 = stage1FormulaLow(16)-60;
		desiredStage2 = stage2FormulaLow(16)+80;
		wait1Msec(380);
		desiredStage2 = 50;
		wait1Msec(100);
	}
	//cone4
	else if(cone == 4){
		desiredStage1 = stage1FormulaLow(25)-90;//26.75
		wait1Msec(500);
		desiredStage2 = stage2FormulaLow(25)+75;//26.75
		wait1Msec(490);
		desiredStage1 = stage1FormulaLow(19)-50;
		desiredStage2 = stage2FormulaLow(19)+80;
		wait1Msec(540);
		desiredStage2 = 50;
		wait1Msec(100);
	}
	//cone5
	else if(cone == 5){
		desiredStage1 = -670;
		wait1Msec(430);
		desiredStage2 = 250;
		wait1Msec(460);
		desiredStage2 = 42;
		wait1Msec(240);
		desiredStage1 = -460;
		desiredStage2 = -50;
		wait1Msec(250);
		desiredStage2 = 60;
		wait1Msec(100);
	}
	//cone6
	else if(cone == 6){
		desiredStage1 = stage1FormulaHigh(35.5);
		wait1Msec(200);
		desiredStage1 = stage1FormulaHigh(31.75);
		desiredStage2 = stage2FormulaHigh(31.75)-70;
		wait1Msec(760);
		desiredStage1 = stage1FormulaHigh(23.5)+35;
		desiredStage2 = stage2FormulaHigh(23.5)-100;
		wait1Msec(320);
		groundSetUpCone();
		desiredStage1 = 10;
		wait1Msec(420);
	}
	//cone7
	else if(cone == 7){
		desiredStage1 = stage1FormulaHigh(35.5);
		wait1Msec(200);
		desiredStage1 = stage1FormulaHigh(34.75)-30;
		desiredStage2 = stage2FormulaHigh(34.25)-125;
		wait1Msec(740);
		desiredStage1 = stage1FormulaHigh(26)-5;
		desiredStage2 = stage2FormulaHigh(26)-150;
		wait1Msec(360);
		groundSetUpCone();
		desiredStage1 = stage1FormulaHigh(26);
		wait1Msec(200);
	}
	//cone8
	else if(cone == 8){
		desiredStage1 = stage1FormulaHigh(36.75);
		wait1Msec(250);
		desiredStage2 = stage2FormulaHigh(36.75)-100;
		wait1Msec(760);
		desiredStage1 = stage1FormulaHigh(28.5)-15;
		desiredStage2 = stage2FormulaHigh(28.5)-125;
		wait1Msec(290);
		groundSetUpCone();
		desiredStage1 = stage1FormulaHigh(28.5);
		wait1Msec(200);
	}
	//cone9
	else if(cone == 9){
		desiredStage1 = stage1FormulaHigh(39.25)-25;
		wait1Msec(310);
		desiredStage2 = stage2FormulaHigh(39.25)-125;
		wait1Msec(790);
		desiredStage1 = stage1FormulaHigh(31)-25;
		desiredStage2 = stage2FormulaHigh(31)-150;
		wait1Msec(370);
		groundSetUpCone();
		desiredStage1 = stage1FormulaHigh(31)+5;
		wait1Msec(200);
	}
	//cone10
	else if(cone == 10){
		desiredStage1 = stage1FormulaHigh(41.75)-25;
		wait1Msec(370);
		desiredStage2 = stage2FormulaHigh(41.75)-80;
		wait1Msec(760);
		desiredStage1 = stage1FormulaHigh(33.5)+20;
		desiredStage2 = stage2FormulaHigh(33.5)-105;
		wait1Msec(365);
	}
	//cone11
	else if(cone == 11){
		desiredStage1 = stage1FormulaHigh(44.25)-52;
		wait1Msec(470);
		desiredStage2 = stage2FormulaHigh(44.25)-110;
		wait1Msec(760);
		desiredStage1 = stage1FormulaHigh(36)-5;
		desiredStage2 = stage2FormulaHigh(36)-110;
		wait1Msec(340);
	}
	//cone12
	else if(cone == 12){
		desiredStage1 = -685;
		wait1Msec(500);
		desiredStage2 = 700;
		wait1Msec(840);
		desiredStage2 = 860;
		wait1Msec(330);
		desiredStage1 = -590;
		wait1Msec(120);
		desiredStage1 = -460;
		desiredStage2 = 895;
		wait1Msec(380);
		desiredStage1 = -400;
		wait1Msec(80);
	}
	groundSetUpCone();
}

float stage1FormulaHighGoal(float inches){
	return 1.0265*inches*inches - 44.529*inches - 130.82;
}

float stage2FormulaHighGoal(float inches){
	return 0.5676*inches*inches + 3.1869*inches + 76.881;
}
//coneH
void highStackCone(int cone){
	if(cone==6){
		desiredStage1 = stage1FormulaHighGoal(18+2.5*cone)-5;
		desiredStage2 = stage2FormulaHighGoal(18+2.5*cone)+15;
	}
	else{
		desiredStage1 = stage1FormulaHighGoal(16+2.5*cone);
		desiredStage2 = stage2FormulaHighGoal(16+2.5*cone);
	}
}

void highStackDetach(int cone){
	desiredStage1 = stage1FormulaHighGoal(10.2+2.5*cone);
	desiredStage2 = stage2FormulaHighGoal(10.2+2.5*cone);
	wait1Msec(200);
	desiredStage1 = -250;
	desiredStage2 = 460;
}

task coneControl(){
	currentConeStack = 0;
	currentHighConeStack = 0;
	bool pickUpCone = false;
	highGoal = false;
	bool highGoalAccurate = false;
	bool messUpButton = false;
	bool incButton = false;
	bool highGoalWait = false;
	bool highGoalDetach = false;
	while(true){
		if(!highGoal){
			if(vexRT[Btn8D]){
				currentConeStack = 0;
			}
			if(vexRT[Btn8R] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentConeStack > 0){
					currentConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentConeStack < 11){
					currentConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					groundPickUpCone();
					wait1Msec(200);
					currentConeStack++;
					normalStackCone(currentConeStack);
					stage1Change = true;
				}
			}
		}
		if(highGoal){
			if(vexRT[Btn8D]){
				currentHighConeStack = 0;
			}
			if(vexRT[Btn8R] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentHighConeStack > 0){
					currentHighConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentHighConeStack < 7){
					currentHighConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					if(highGoalWait){
						highGoalWait = false;
						highGoalDetach = true;
						highStackDetach(currentHighConeStack);
					}
					else if(highGoalDetach){
						highGoalWait = false;
						highGoalDetach = false;
						groundSetUpCone();
					}
					else if(currentHighConeStack < 7){
						groundPickUpCone();
						wait1Msec(200);
						currentHighConeStack++;
						highStackCone(currentHighConeStack);
						stage1Change = true;
						highGoalWait = true;
						highGoalDetach = false;
					}
				}
			}
		}
		if(vexRT[Btn7U] != highGoalAccurate){
			highGoalAccurate = !highGoalAccurate;
			if(highGoalAccurate){
				highGoal = !highGoal;
				SensorValue(highGoalLight) = highGoal;
			}
		}
		if(vexRT[Btn8R])
			preloadPickUpCone();
		delay(5);
	}
}

task sideRollers(){
	while(true){
		if(vexRT[Btn5U]){
			sideRoller(127);
		}
		else if(vexRT[Btn5D]){
			sideRoller(-127);
		}
		else{
			sideRoller(0);
		}
		delay(10);
	}
}

void pre_auton() {
	wait1Msec(100);
}

task autonomous(){

}

int height=10;
int cone = 1;
task usercontrol(){
	SensorValue(stage1Encoder) = 0;
	//SensorValue(stage2Encoder) = 0;
	//startTask(coneControl);
	startTask(driveControl);
	//startTask(stage1Control);
	//startTask(stage2Control);
	//startTask(mobileGoalMotors);
	startTask(sideRollers);
	while(true){
		if(vexRT[Btn7R]){
			SensorValue(stage2Encoder) = 0;
			startTask(stage1Control);
			startTask(stage2Control);
		}
		if(vexRT[Btn8D]) {
			groundPickUpCone();
			//preloadPickUpCone();
		}
		if(vexRT[Btn8U]) {
			groundSetUpCone();
			//preloadSetUpCone();
		}
		if(vexRT[Btn7D]) {
			cone--;
			while(vexRT[Btn7D]){
				delay(5);
			}
		}
		if(vexRT[Btn7U]){
			normalStackCone(cone);
			cone++;
		}
		if(vexRT[Btn7L]){
			cone=0;
		}
	}
	/**while(true){
		if(vexRT[Btn7R]){
			SensorValue(stage2Encoder) = 0;
			startTask(stage1Control);
			startTask(stage2Control);
		}
		if(vexRT[Btn8D])
			groundPickUpCone();
		if(vexRT[Btn8U])
			groundSetUpCone();
		if(vexRT[Btn7D]){
			cone++;
			while(vexRT[Btn7D]){
				delay(5);
			}
			wait1Msec(100);
		}
		if(vexRT[Btn7U]){
			highStackCone(cone);
		}
		if(vexRT[Btn7L]){
			highStackDetach(cone);
		}
	}*/
	/**while(true){
		if(vexRt[Btn7U]){
			height++;
			wait1Msec(500);
			desiredStage1=stage1FormulaHighGoal(height);
			desiredStage2=stage2FormulaHighGoal(height);
		}
		if(vexRT[Btn7R]){
			SensorValue(stage2Encoder) = 0;
			startTask(stage1Control);
			startTask(stage2Control);
		}
	}*/
}
