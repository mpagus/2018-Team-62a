#pragma config(Sensor, in1,    intakeEncoder,  sensorPotentiometer)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           leftDrive1,    tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftDrive3,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           rightDrive3,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightDrive1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightDrive2,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           intakeL,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           intakeR,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftDrive2,    tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "MilesLib.h"

//////////////////////////////////////////////////
//   _____                       __  ____       //
// |_   _|__  __ _ _ __ ___    / /_|___ \ __ _  //
//   | |/ _ \/ _` | '_ ` _ \  |  _ \ __) / _` | //
//   | |  __/ (_| | | | | | | | (_) / __/ (_| | //
//   |_|\___|\__,_|_| |_| |_|  \___/_____\__,_| //
//                                              //
//////////////////////////////////////////////////

//datalogAddValueWithTimeStamp(0, driveSpeed)

bool mobileGoal = true;
bool autonRan = false;

void intake(int val){
	motor[intakeL] = motor[intakeR] = val;
}

void drive(int rVal, int lVal){
	motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = rVal;
	motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = lVal;
}

task mobileGoalMotors(){
	bool accurate = false;
	while(true){
		if(!mobileGoal){
			if(SensorValue(intakeEncoder) < 2650)
				intake(127);
			else
				intake(5);
		}
		else{
			if(SensorValue(intakeEncoder) > 1750)
				intake(-127);
			else
				intake(-2);
		}
		if(vexRT[Btn5U] != accurate){
			accurate = !accurate;
			if(accurate)
				mobileGoal = !mobileGoal;
		}
		delay(5);
	}
}

void mobileGoalOut(){
	mobileGoalGeneralLess(127, 2, 2600);
}

void mobileGoalIn(){
	mobileGoalGeneralGreater(-127, -10, 1750);
}

int gyroLeftIsPositive(){
	return 1;
}

#include "Team 62 Mark IV Skills.c"
//#include "Team 62 Mark IV Match.c"

void pre_auton() {calibrateGyros();}

task autonomous(){
	//auton();
	testPID();
	//testTurn();
}

task usercontrol(){
	startTask(driveControl);
	startTask(mobileGoalMotors);
}
