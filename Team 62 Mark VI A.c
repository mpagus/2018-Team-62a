#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  stage2Encoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  mobileGoalButton, sensorTouch)
#pragma config(Sensor, dgtl8,  stage1Encoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl10, ultrasonthicccccccc, sensorSONAR_mm)
#pragma config(Sensor, dgtl12, coneButton,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           stage1,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           intakeR,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           intakeL,       tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           rightDrive2,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftDrive2,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           leftDrive1,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rightDrive1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightDrive3,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftDrive3,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          stage2,        tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "MilesLib.h"

////////////////////////////////////////////////////
//    _____                       __  ___         //
//  |_   _|__  __ _ _ __ ___    / /_|___ \ __ _   //
//    | |/ _ \/ _` | '_ ` _ \  |  _ \ __) / _` |  //
//    | |  __/ (_| | | | | | | | (_) / __/ (_| |  //
//    |_|\___|\__,_|_| |_| |_|  \___/_____\__,_|  //
//                                                //
////////////////////////////////////////////////////

//Note to Cameron: please start by button testing the program and inputting the sensors
//Next start tuning the mobile goal intake states and the values for each
//Next start reading values for normal stacking cones
//Then add the pickup locations and stuff
//Then add preload capability
//Then add high goal shit

float batteryPower; //battery power uopdated in DataLog task always running in the background
bool mobileGoal = true;
float startStage1 = 0;
float startStage2 = 0;
float endStage1 = 0;
float endStage2 = 0;
float velocitySlope = 0;
float maxVelocity = 0;
float rampTime = 0;
float steadyTime = 0;
int currentConeStack = 0;
int currentHighConeStack = 0;
bool autonRan = false;
bool mobileTip = false;
bool mobileUntip = false;
bool mobileGoalTip = false;
bool intakeLowered = true;
bool letIntakeGo = false;
int autonNumber = 0;
int followPath = 0;
bool start = false;
bool completed = false;

//Used to assign motor powers to intake
void intake(int val){
	motor[intakeL] = motor[intakeR] = val;
}

//Used to assign motor powers to intake (seperate sides)
void intakeSides(int rval, int lval){
	motor[intakeL] = lval;
	motor[intakeR] = rval;
}

//Used to assign motor powers to drive
void drive(int rVal, int lVal){
	motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = rVal;
	motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = lVal;
}

//Used to assign motor powers to stage 1
void towerStage1(int val){
	motor[stage1] = val;
}

//Used to assign motor powers to stage 2
void towerStage2(int val){
	motor[stage2] = val;
}

//Reset lift encoders
void resetLiftEncoders(){
	SensorValue(stage1Encoder) = 0;
	SensorValue(stage2Encoder) = 0;
}

float motionPIDGraphStage1(float time){
	if(followPath == -1){ //Unfold Robot Auton_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 0){ //Unfold Robot_1
		if(time<760)
			return polynom(time,0,0.404,0.0016,sciN(-2,-6),0,0,0);
		else{
			completed = true;
			return 268;
		}
	}
	else if(followPath == 1){ //PickUpCone_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 2){ //SetUpCone_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 3){ //Cone1_1
		if(time<1950)
			return polynom(time,sciN(2.480,2),sciN(2.958,-1),sciN(-8.441,-4),sciN(-9.652,-7),sciN(2.291,-9),sciN(-1.252,-12),sciN(2.175,-16));
		else{
			completed = true;
			return 268;
		}
	}
	else if(followPath == 4){ //Cone2_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 5){ //Cone3_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 6){ //Cone4_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 7){ //Cone5_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 8){ //Cone6_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 9){ //Cone7_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 10){ //Cone8_1
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 100){ //Choose Your Path_1
		if(time<rampTime)
			return 0;
		else if(time<rampTime+steadyTime)
			return 0;
		else if(time<rampTime+rampTime+steadyTime)
			return 0;
		else
			return endStage1;
	}
	return SensorValue(stage1Encoder);
}

float motionPIDGraphStage2(float time){
	if(followPath == -1){ //Unfold Robot Auton_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 0){ //Unfold Robot_2
		if(time<750)
			return polynom(time,0,0.9382,-0.009,sciN(4,-5),sciN(-6,-8),sciN(3,-11),0);
		else{
			completed = true;
			return 634;
		}
	}
	else if(followPath == 1){ //PickUpCone_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 2){ //SetUpCone_2
		if(time<1950)
			return 0;
		else{
			completed = true;
			return 0;
		}
	}
	else if(followPath == 3){ //Cone1_2
		if(time<1950)
			return polynom(time,sciN(6.350,2),sciN(1.811,-1),sciN(-2.586,-3),sciN(7.276,-6),sciN(-7.613,-9),sciN(3.426,-12),sciN(-5.628,-16));
		else{
			completed = true;
			return 634;
		}
	}
	else if(followPath == 4){ //Cone2_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 5){ //Cone3_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 6){ //Cone4_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 7){ //Cone5_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 8){ //Cone6_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 9){ //Cone7_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	else if(followPath == 10){ //Cone8_2
		if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else if(time<1000)
			return 0*time;
		else{
			completed = true;
			return 0*time;
		}
	}
	return SensorValue(stage2Encoder);
}

long startTime = nPgmTime-10;
task motionPID(){
	int windowSize = 20;
	float kP1 = 0.9;
	float kI1 = 0.0005;
	float kD1 = 40;
	float error1 = 0;
	float integral1 = 0;
	float derivative1 = 0;
	float old1 = 0;
	float kP2 = 0.4;
	float kI2 = 0.0001;
	float kD2 = 20;
	float error2 = 0;
	float integral2 = 0;
	float derivative2 = 0;
	float old2 = 0;
	long oldTime = nPgmTime-5;
	while(true){
		if(start){
			startTime = nPgmTime;
			start = false;
		}
		error1 = motionPIDGraphStage1(nPgmTime-startTime+windowSize) - SensorValue(stage1Encoder);
		integral1 = integral1 + error1*(nPgmTime-oldTime);
		derivative1 = (error1 - old1)/(nPgmTime-oldTime);
		if(abs(error1)<1 || abs(error1)>100){
			integral1 = 0;
		}
		old1 = error1;
		towerStage1(limit(error1 * kP1 + integral1 * kI1 + derivative1 * kD1, -127, 127));

		error2 = motionPIDGraphStage2(nPgmTime-startTime+windowSize) - SensorValue(stage2Encoder);
		integral2 = integral2 + error1*(nPgmTime-oldTime);
		derivative2 = (error2 - old2)/(nPgmTime-oldTime);
		if(abs(error2)<1 || abs(error2)>100){
			integral2 = 0;
		}
		old2 = error2;
		towerStage2(limit(error2 * kP2 + integral2 * kI2 + derivative2 * kD2, -127, 127));

		oldTime = nPgmTime;
		delay(20);
	}
}

void moveToPosition(float _startStage1, float _startStage2, float _endStage1, float _endStage2, float _velocitySlope, float _maxVelocity){
	startStage1 = _startStage1;
	startStage2 = _startStage2;
	endStage1 = _endStage1;
	endStage2 = _endStage2;
	velocitySlope = _velocitySlope;
	maxVelocity = _maxVelocity;
	followPath = 100;
	completed = false;
	start = true;
	while(!completed){
		wait1Msec(75);
	}
}

void moveArm(int path){
	followPath = path;
	completed = false;
	start = true;
	while(!completed){
		wait1Msec(75);
	}
}

void normalStackCone(int cone){
	if(cone<9)
		moveArm(cone+2);
}

void groundSetUpCone(){
	moveArm(2);
}

void groundPickUpCone(){
	moveArm(1);
}

void unfoldRobot(){
	moveArm(0);
}

void unfoldRobotAuton(){
	moveArm(-1);
}

task coneControl(){
	currentConeStack = 0;
	currentHighConeStack = 0;
	bool highGoalDetach = false;
	bool pickUpCone = false;
	bool messUpButton = false;
	bool incButton = false;
	bool coneButton = false;
	intakeLowered = true;
	bool outHigh = false;
	bool aAccurate = false;
	while(true){
		if(!vexRT[Btn7L]){ //Normal mode
			if(vexRT[Btn8R]){ //Reset cone height
				currentConeStack = 0;
			}
			if(vexRT[Btn8D] != messUpButton){ //Decrease cone height
				messUpButton = !messUpButton;
				if(messUpButton && currentConeStack > 0){
					currentConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){ //Increase cone height
				incButton = !incButton;
				if(incButton && currentConeStack < 7){
					currentConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){ //Pick up cone
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					wait1Msec(300);
					if(!vexRT[Btn6U] && currentConeStack < 8){
						currentConeStack++;
						normalStackCone(currentConeStack);
						groundSetUpCone();
						intakeLowered = true;
					}
					while(vexRT[Btn6U]){
						if(SensorValue(ultrasonthicccccccc)<62){
							groundPickUpCone();
							wait1Msec(100);
							currentConeStack++;
							normalStackCone(currentConeStack);
							groundSetUpCone();
							intakeLowered = true;
						}
					}
				}
			}
		}
		/**else{ //High goal mode
			if(vexRT[Btn8R]){ //Reset cone height
				currentHighConeStack = 0;
			}
			if(vexRT[Btn8D] != messUpButton){ //Decrease cone height
				messUpButton = !messUpButton;
				if(messUpButton && currentHighConeStack > 0){
					currentHighConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){ //Increase cone height
				incButton = !incButton;
				if(incButton && currentHighConeStack < 7){
					currentHighConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){ //Toggle BEtween above stack height on high goal and dropping the cone
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					if(highGoalDetach){
						highGoalDetach = false;
						highStackDetach(currentHighConeStack);
					}
					else if(currentHighConeStack < 7){
						currentHighConeStack++;
						highStackCone(currentHighConeStack);
						highGoalDetach = true;
						intakeLowered = false;
					}
				}
			}
		}*/
		if(vexRT[Btn6D] != coneButton){ //Toggle between above cone and at cone height for pickup
			coneButton = !coneButton;
			if(coneButton){
				if(intakeLowered){
					groundPickUpCone();
					intakeLowered = false;
				}
				else{
					groundSetUpCone();
					intakeLowered = true;
				}
			}
		}
		if(vexRT[Btn5U] != aAccurate && vexRT[Btn5D] != aAccurate){ //creates the lock to pause this task while the mobile goal moves (no multi-threading errors)
			aAccurate = !aAccurate;
			if(aAccurate){
				letIntakeGo = true;
				while(letIntakeGo){
					delay(50);
				}
			}
		}
		delay(20);
	}
}

//The mobile goal task for user control.
task mobileGoalMotors(){
	bool accurate = false;
	bool baccurate = false;
	bool caccurate = false;
	mobileGoal = true;
	int outCount = 0;
	int inCount = 111;
	int integral = 0;
	while(true){
		//Tipping mode
		if(mobileTip){
			if(mobileGoalTip){
				integral+=310-nMotorEncoder[intakeL];
				intake(0.85*(310-nMotorEncoder[intakeL])+0.001*integral); //general pid to get it to the pre-tip value
				if(SensorValue(mobileGoalButton)){
					mobileGoalTip = false;
					integral=0;
				}
			}
			else{
				intakeSides(30, 45); //brings the intake down unevenly
			}
		}
		//Untipping mode
		else if(mobileUntip){
			integral+=310-nMotorEncoder[intakeL];
			intake(0.85*(310-nMotorEncoder[intakeL])+0.001*integral); //general pid to keep it at the untip value
		}
		//Mobile goal out
		else if(!mobileGoal){
			if(outCount<100){
				intake(127);
				outCount++;
			}
			else if(outCount<130){
				intake(30);
				outCount++;
			}
			else{
				if(vexRT[Ch2] > 5 || vexRT[Ch3] > 5)
					intake(19);
				else
					intake(0);
			}
		}
		//Mobile goal in
		else{
			if(inCount<102){
				intake(-127);
				inCount++;
			}
			else if(inCount<115){
				intake(-7);
				inCount++;
			}
			else
				intake(-2);
		}
		//Out/in control
		if(vexRT[Btn5U] != accurate){
			accurate = !accurate;
			if(accurate){
				//while(!letIntakeGo){
					//wait1Msec(15); //This is essentially a lock that waits for the cone control method to pause for the mobile goal to move (it pritects against multi-threading errors)
				//}
				mobileGoal = !mobileGoal;
				inCount = 0;
				outCount = 0;
				mobileTip = false;
				mobileGoalTip = false;
				/**if(!mobileGoal){
					//This moves the arm out of the way to different locations based on the cone stack (If the arm moves out)
					if(currentConeStack<=5){
						getOutOfTheWayMid();
						intakeLowered = false;
					}
					else{
						getOutOfTheWay();
						wait1Msec(200 + 25*currentConeStack);
						intakeLowered = false;
					}
					currentConeStack = 0;
				}*/
				letIntakeGo = false;
			}
		}
		//Tipping control
		if(vexRT[Btn5D] != baccurate){
			baccurate = !baccurate;
			if(baccurate){
				integral=0;
				mobileTip = true;
				mobileGoalTip = true;
				mobileGoal = true;
				mobileUntip = false;
			}
		}
		//Untipping control
		if(vexRT[Btn7D] != caccurate){
			caccurate = !caccurate;
			if(caccurate){
				integral = 0;
				mobileUntip = true;
				mobileTip = false;
			}
		}
		delay(5);
	}
}

//Auton mobile goal task runs in the background without control except the mobileGoal boolean.
//The mobile goal task for user control.
task mobileGoalAuton(){
	mobileGoal = true;
	int outCount = 0;
	int inCount = 0;
	while(true){
		//Mobile goal out
		if(!mobileGoal){
			if(outCount<100){
				intake(127);
				outCount++;
			}
			else if(outCount<130){
				intake(30);
				outCount++;
			}
			else{
				if(vexRT[Ch2] > 5 || vexRT[Ch3] > 5)
					intake(19);
				else
					intake(0);
			}
		}
		//Mobile goal in
		else{
			if(inCount<102){
				intake(-127);
				inCount++;
			}
			else if(inCount<115){
				intake(-7);
				inCount++;
			}
			else
				intake(-2);
		}
		delay(5);
	}
}

//This task constantly runs in the background. Change the values as needed to get that data!
task dataLog(){
	datalogClear();
	datalogStart();
	while(true){
		datalogAddValueWithTimeStamp(0, motionPIDGraphStage1(nPgmTime-startTime));
		datalogAddValueWithTimeStamp(1, SensorValue(stage1Encoder));
		datalogAddValueWithTimeStamp(2, motor[stage1]);
		datalogAddValueWithTimeStamp(3, motionPIDGraphStage2(nPgmTime-startTime));
		datalogAddValueWithTimeStamp(4, SensorValue(stage2Encoder));
		datalogAddValueWithTimeStamp(5, motor[stage2]);
		batteryPower = nImmediateBatteryLevel;
		delay(50);
	}
}

//This refers to the autonomus stuff. I would reccommend doing nothing to this file. It gives all the functions for autonomous.
//#include "Team 62 Mark VI Match.c"

//This runs at the beginning of each reboot and calibrates the gyro. Keep the robot still for 2 seconds to calibrate.
void pre_auton() {
	//calibrateGyros();
}

//This takes from Match for get the auton function which takes one of the possible autons.
//The testPID() is the only test you need that goes back and forth to test straight and turning pid.
task autonomous(){
	startTask(dataLog);
	//auton(autonNumber);
	//testPID();
	//testTurn();
}

//User control only deploys when autonRan is false
task usercontrol(){
	/**startTask(dataLog);
	startTask(coneControl);
	startTask(driveControl);
	startTask(mobileGoalMotors);
	resetEncoders();
	if(!autonRan){
		resetLiftEncoders();
		startTask(stage1Control);
		startTask(stage2Control);
		//startTask(stallCheck);
		unfoldRobot();
	}
	else{
		startTask(stage1Control);
		startTask(stage2Control);
		//startTask(stallCheck);
		autonRan = false;
		//mobileGoal = false;
		//groundSetUpConeWait();
		getOutOfTheWayMid();
	}*/
	resetLiftEncoders();
	//nMotorEncoder[intakeL]=0;
	startTask(dataLog);
	//startTask(coneControl);
	//startTask(driveControl);
	//startTask(mobileGoalMotors);
	//followPath = -1;
	//startTask(motionPID);
	//wait1Msec(100);
	//moveArm(0);
	//wait1Msec(1000);
	//moveArm(3);
}
