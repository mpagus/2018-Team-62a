#pragma config(Sensor, in1,    intakeEncoder,  sensorPotentiometer)
#pragma config(Sensor, in3,    GyroBottom,     sensorGyro)
#pragma config(Sensor, in4,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  stage2Encoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  stage1Encoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  highGoalLight,  sensorDigitalOut)
#pragma config(Motor,  port1,           leftDrive3,    tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           rightDrive1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftDrive1,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           rightDrive2,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightDrive3,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           stage2,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           stage1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           intakeL,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           intakeR,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          leftDrive2,    tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "MilesLib.h"

////////////////////////////////////////////////////
//    _____                       __  ___         //
//  |_   _|__  __ _ _ __ ___    / /_|___ \ __ _   //
//    | |/ _ \/ _` | '_ ` _ \  |  _ \ __) / _` |  //
//    | |  __/ (_| | | | | | | | (_) / __/ (_| |  //
//    |_|\___|\__,_|_| |_| |_|  \___/_____\__,_|  //
//                                                //
////////////////////////////////////////////////////

float batteryPower;

bool mobileGoal = true;
float desiredStage1 = 0;
float desiredStage2 = 0;
bool stage1Reset = false;
float stage2Scalar = 317;
bool highGoal = false;
int currentConeStack = 0;
int currentHighConeStack = 0;
bool autonRan = false;
bool mobileTip = false;
bool mobileUntip = false;
bool mobileGoalTip = false;
bool resetSlewStage2 = false;
bool intakeLowered = true;
bool letIntakeGo = false;

void intake(int val){
	motor[intakeL] = motor[intakeR] = val;
}

void intakeSides(int rval, int lval){
	motor[intakeL] = lval;
	motor[intakeR] = rval;
}

void drive(int rVal, int lVal){
	motor[rightDrive1] = motor[rightDrive2] = motor[rightDrive3] = rVal;
	motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = lVal;
}

void towerStage1(int val){
	motor[stage1] = val;
}

void towerStage2(int val){
	motor[stage2] = val;
}

void resetLiftEncoders(){
	SensorValue(stage1Encoder) = 0;
	SensorValue(stage2Encoder) = 0;
}

int gyroLeftIsPositive(){
	return 1;
}

task stage1Control(){
	float old = SensorValue(stage1Encoder);
	desiredStage1 = SensorValue(stage1Encoder);
	float kP1 = 0.85;
	float kI1 = 0;
	float kD1 = 9;
	float error = 0;
	float integral = 0;
	float derivative = 0;
	while(true){
		error = desiredStage1 - SensorValue(stage1Encoder);
		integral = integral + error;
		if(deadband(error, 0, 20) || stage1Reset){
			integral = 0;
			stage1Reset = false;
		}
		if(abs(error)>200){
			integral = 0;
		}
		derivative = error - old;
		old = error;
		towerStage1(limit(error * kP1 + integral * kI1 + derivative * kD1, -100, 100));
		delay(5);
	}
}

int numRevolutions = 0;
int ticksPerRevolution = 1080;

task stage2Control(){
	desiredStage2 = (SensorValue(stage2Encoder) - stage2Scalar);
	float old = SensorValue(stage2Encoder);
	float kP2 = 0.46;
	float kD2 = 4.5;
	float error = 0;
	float derivative = 0;
	int slewVal = 15;
	while(true){
		if(resetSlewStage2){
			slewVal = 15;
			resetSlewStage2 = false;
		}
		error = (desiredStage2+numRevolutions*ticksPerRevolution) - (SensorValue(stage2Encoder) - stage2Scalar);
		derivative = error - old;
		old = error;
		towerStage2(slew(&slewVal, limit(error*kP2 + derivative*kD2/2), 8, 5));
		//towerStage2(limit(error*kP2 + derivative*kD2/2));
		delay(2);
	}
}

task stallCheck(){
	float oldEncoderStage1 = SensorValue(stage1Encoder);
	float oldEncoderStage2 = SensorValue(stage2Encoder);
	int stage1Tick = 0;
	int stage2Tick = 0;
	while (true){
		oldEncoderStage1 = SensorValue(stage1Encoder);
		oldEncoderStage2 = SensorValue(stage2Encoder);
		if(stage1Tick>30){
			stopTask(stage1Control);
			wait1Msec(100);
			startTask(stage1Control);
		}
		if(stage2Tick>30){
			stopTask(stage2Control);
			wait1Msec(100);
			startTask(stage2Control);
		}
		if(abs(SensorValue(stage1Encoder) - oldEncoderStage1)>25 && abs(desiredStage1 - SensorValue(stage1Encoder))>20)
			stage1Tick++;
		else
			stage1Tick = 0;
		if(abs(SensorValue(stage2Encoder) - oldEncoderStage2)>25 && abs(desiredStage2+numRevolutions*ticksPerRevolution) - (SensorValue(stage2Encoder) - stage2Scalar)>20)
			stage2Tick++;
		else
			stage2Tick = 0;
		wait1Msec(75);
	}
}

void moveStage1WaitUntil(float desiredValue, float continueValue){
	desiredStage1 = desiredValue;
	moveSingleStageWaitUntil(stage1Encoder, continueValue, 20);
}

void moveStage1Wait(float desiredValue){
	desiredStage1 = desiredValue;
	moveSingleStageWait(stage1Encoder, desiredValue, 20, 20, 6);
}

void moveStage2WaitUntil(float desiredValue, float continueValue){
	desiredStage2 = desiredValue;
	resetSlewStage2 = true;
	//moveSingleStageWaitUntil(stage2Encoder, continueValue, 50);
	moveSingleStageWaitUntil(stage2Encoder, continueValue+numRevolutions*ticksPerRevolution + stage2Scalar, 20);
}

void moveStage2Wait(float desiredValue){
	desiredStage2 = desiredValue;
	resetSlewStage2 = true;
	//moveSingleStageWait(stage2Encoder, desiredValue, 50, 50);
	moveSingleStageWait(stage2Encoder, desiredValue+numRevolutions*ticksPerRevolution + stage2Scalar, 20, 20, 6);
}

void moveBothStagesWait(float desiredValue1, float desiredValue2){
	desiredStage1 = desiredValue1;
	desiredStage2 = desiredValue2;
	resetSlewStage2 = true;
	//moveDoubleStageWait(stage1Encoder, desiredValue1, 60, 60, stage2Encoder, desiredValue2,  60, 60);
	moveDoubleStageWait(stage1Encoder, desiredValue1, 20, 20, stage2Encoder, desiredValue2+numRevolutions*ticksPerRevolution + stage2Scalar, 20, 20, 6);
}

void stage2RevolutionNoWait(){
	numRevolutions = numRevolutions+1;
	resetSlewStage2 = true;
}

void stage2Revolution(){
	numRevolutions = numRevolutions+1;
	resetSlewStage2 = true;
	moveSingleStageWait(stage1Encoder, desiredStage2+numRevolutions*ticksPerRevolution - stage2Scalar, 20, 20, 6);
}

void groundPickUpCone(){
	//desiredStage1 = -20;
	desiredStage2 = 25;
	stopTask(stage1Control);
	towerStage1(-127);
	wait1Msec(520);
	startTask(stage1Control);
	desiredStage1 = 10;
	wait1Msec(50);
}

void groundPickUpConeWait(){
	moveBothStagesWait(-20, 25);
}

void groundSetUpCone(){
	desiredStage1 = 185;
	desiredStage2 = 25;
}

void groundSetUpConeWait(){
	moveBothStagesWait(185, 10);
}

void preloadPickUpCone(){
	desiredStage1 = 185;
	desiredStage2 = 25;
}

void preloadSetUpCone(){
	desiredStage1 = 185;
	desiredStage2 = 25;
}

void normalStackCone(int cone, bool preload = false){
	//cone1
	if(cone == 1){
		moveStage2WaitUntil(90, 60);
		moveStage1WaitUntil(375, 345);
		moveBothStagesWait(385, -200);
		moveBothStagesWait(145, -195);
	}
	//cone2
	else if(cone == 2){
		moveStage2WaitUntil(90, 60);
		moveStage1WaitUntil(435, 405);
		moveBothStagesWait(465, -160);
		moveBothStagesWait(215, -215);
	}
	//cone3
	else if(cone == 3){
		moveStage2WaitUntil(90, 60);
		moveStage1WaitUntil(640, 515);
		moveBothStagesWait(640, -85);
		moveBothStagesWait(235, -235);
	}
	//cone4
	else if(cone == 4){
		//moveStage1Wait(450);
		//stage2RevolutionNoWait();
		//moveStage1Wait(455);
		//moveStage2Wait(50);
		moveStage1WaitUntil(275, 130);
		moveBothStagesWait(287, 755);
		//moveStage1Wait(130);
		desiredStage1 = 55;
		wait1Msec(200);
		groundSetUpCone();
		desiredStage1 = 120;
		wait1Msec(200);
	}
	//cone5
	else if(cone == 5){
		//moveStage1Wait(480);
		//stage2RevolutionNoWait();
		//moveStage1Wait(490);
		//moveStage2Wait(50);
		moveStage1WaitUntil(350, 130);
		moveBothStagesWait(355, 755);
		//moveStage1Wait(172);
		desiredStage1 = 115;
		wait1Msec(200);
		groundSetUpCone();
		desiredStage1 = 200;
		wait1Msec(200);
	}
	//cone6
	else if(cone == 6){
		moveStage1WaitUntil(405, 130);
		moveBothStagesWait(410, 760);
		//moveStage1Wait(295);
		desiredStage1 = 30;
		wait1Msec(200);
		groundSetUpCone();
		desiredStage1 = 250;
		wait1Msec(200);
	}
	//cone7
	else if(cone == 7){
		moveStage1WaitUntil(440, 130);
		moveBothStagesWait(460, 685);
		//moveStage1Wait(360 - 10);
		desiredStage1 = 280;
		wait1Msec(170);
		groundSetUpCone();
		desiredStage1 = 300;
		wait1Msec(100);
	}
	//cone8
	else if(cone == 8){
		moveStage1WaitUntil(660, 300);
		moveBothStagesWait(660, 502);
		moveBothStagesWait(470, 685);
		//moveStage1Wait(390);
		desiredStage1 = 350;
		wait1Msec(140);
		groundSetUpCone();
		desiredStage1 = 360;
		wait1Msec(100);
	}
}

//coneH
void highStackCone(float cone){
	//cone1H
	if(cone == 1){
		moveBothStagesWait(145, -195);
	}
	//cone2H
	else if(cone == 2){
		moveBothStagesWait(215, -215);
	}
	//cone3H
	else if(cone == 3){
		moveBothStagesWait(235, -235);
	}
	//cone4H
	else if(cone == 4){
		moveBothStagesWait(287, 755);
	}
	//cone5H
	else if(cone == 5){
		moveBothStagesWait(355, 755);
	}
}

//coneD
void highStackDetach(int cone){
	//cone1D
	if(cone == 1){
		moveBothStagesWait(145, -195);
	}
	//cone2D
	else if(cone == 2){
		moveBothStagesWait(215, -215);
	}
	//cone3D
	else if(cone == 3){
		moveBothStagesWait(235, -235);
	}
	//cone4D
	else if(cone == 4){
		moveBothStagesWait(287, 755);
	}
	//cone5D
	else if(cone == 5){
		moveBothStagesWait(355, 755);
	}
	wait1Msec(350);
	moveBothStagesWait(-250, 270);
}

void getOutOfTheWay(){
	if(deadband2(SensorValue(stage1Encoder), 620, 100)){
		desiredStage1 = 620;
		desiredStage2 = 982-stage2Scalar;
	}
	else{
		moveStage1WaitUntil(620, 530);
		desiredStage2 = 982-stage2Scalar;
	}
}

void getOutOfTheWayMid(){
	if(deadband2(SensorValue(stage1Encoder), 510, 100)){
		desiredStage1 = 510;
		desiredStage2 = 629-stage2Scalar+510;
	}
	else{
		moveStage1WaitUntil(482, 450);
		desiredStage2 = 629-stage2Scalar+510;
	}
}

void getOutOfTheWayLow(){
	moveStage1WaitUntil(220, 160);
	desiredStage2 = 1080-370;
}

void unfoldRobot(){
	moveStage1Wait(220);
	moveStage2Wait(0);
	moveStage1WaitUntil(482, 450);
	mobileGoal = false;
}

void unfoldRobotAuton(){
	moveStage1Wait(230);
	moveStage2WaitUntil(-415, -350);
	//getOutOfTheWayLow();
}

task coneControl(){
	currentConeStack = 0;
	currentHighConeStack = 0;
	//highGoal = false;
	//bool highGoalAccurate = false;
	bool highGoalDetach = false;
	bool pickUpCone = false;
	bool messUpButton = false;
	bool incButton = false;
	bool coneButton = false;
	intakeLowered = true;
	bool outMid = false;
	bool outHigh = false;
	bool aAccurate = false;
	bool bAccurate = false;
	while(true){
		if(!vexRT[Btn5U] && !vexRT[Btn5D]){
			if(vexRT[Btn8R]){
				currentConeStack = 0;
			}
			if(vexRT[Btn8D] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentConeStack > 0){
					currentConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentConeStack < 7){
					currentConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					if(currentConeStack < 8){
						currentConeStack++;
						normalStackCone(currentConeStack);
						groundSetUpCone();
						stage1Reset = true;
						intakeLowered = true;
					}
				}
			}
			if(vexRT[Btn6D] != coneButton){
				coneButton = !coneButton;
				if(coneButton){
					if(intakeLowered){
						groundPickUpCone();
						intakeLowered = false;
					}
					else{
						groundSetUpCone();
						intakeLowered = true;
					}
				}
			}
		}
		if(vexRT[Btn5D]){
			if(vexRT[Btn8R]){
				currentConeStack = 0;
			}
			if(vexRT[Btn8D] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentConeStack > 0){
					currentConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentConeStack < 7){
					currentConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					if(currentConeStack < 8){
						currentConeStack++;
						normalStackCone(currentConeStack, true);
						preloadSetUpCone();
						stage1Reset = true;
						intakeLowered = true;
					}
				}
			}
			if(vexRT[Btn6D] != coneButton){
				coneButton = !coneButton;
				if(coneButton){
					if(intakeLowered){
						preloadPickUpCone();
						intakeLowered = false;
					}
					else{
						preloadSetUpCone();
						intakeLowered = true;
					}
				}
			}
		}
		else{
			if(vexRT[Btn8R]){
				currentHighConeStack = 0;
			}
			if(vexRT[Btn8D] != messUpButton){
				messUpButton = !messUpButton;
				if(messUpButton && currentHighConeStack > 0){
					currentHighConeStack--;
				}
			}
			if(vexRT[Btn8U] != incButton){
				incButton = !incButton;
				if(incButton && currentHighConeStack < 7){
					currentHighConeStack++;
				}
			}
			if(vexRT[Btn6U] != pickUpCone){
				pickUpCone = !pickUpCone;
				if(pickUpCone){
					if(highGoalDetach){
						highGoalDetach = false;
						highStackDetach(currentHighConeStack);
					}
					else if(currentHighConeStack < 7){
						currentHighConeStack++;
						highStackCone(currentHighConeStack);
						highGoalDetach = true;
						intakeLowered = true;
					}
				}
			}
			if(vexRT[Btn6D] != coneButton){
				coneButton = !coneButton;
				if(coneButton){
					if(intakeLowered){
						groundPickUpCone();
						intakeLowered = false;
					}
					else{
						groundSetUpCone();
						intakeLowered = true;
					}
				}
			}
		}
		/**if(vexRT[Btn7D] != highGoalAccurate){
			highGoalAccurate = !highGoalAccurate;
			if(highGoalAccurate){
				highGoal = !highGoal;
				SensorValue(highGoalLight) = highGoal;
			}
		}*/
		if(vexRT[Btn7R] != outHigh){
			outHigh = !outHigh;
			if(outHigh){
				getOutOfTheWay();
				intakeLowered = false;
			}
		}
		if(vexRT[Btn7D] != outMid){
			outMid = !outMid;
			if(outMid){
				getOutOfTheWayMid();
				intakeLowered = false;
			}
		}
		if(vexRT[Btn5U] != aAccurate && vexRT[Btn5D] != aAccurate){
			aAccurate = !aAccurate;
			if(aAccurate){
				letIntakeGo = true;
				while(letIntakeGo){
					delay(50);
				}
			}
		}
		delay(5);
	}
}

task mobileGoalMotors(){
	bool accurate = false;
	bool baccurate = false;
	bool caccurate = false;
	mobileGoal = true;
	while(true){
		if(mobileTip){
			if(mobileGoalTip)
				intake(-0.15*(SensorValue(intakeEncoder)-1900));
			else{
				if(SensorValue(intakeEncoder) < 2950)
					intakeSides(26, 48);
				else
					intake(0);
			}
		}
		else if(mobileUntip){
			intake(-0.15*(SensorValue(intakeEncoder)-2700));
		}
		else if(!mobileGoal){
			if(SensorValue(intakeEncoder) < 2440)
				intake(127);
			else if(SensorValue(intakeEncoder) < 2560)
				intake(30);
			else
				intake(5);
		}
		else{
			if(SensorValue(intakeEncoder) > 700)
				intake(-127);
			else
				intake(-2);
		}
		if(vexRT[Btn5U] != accurate && vexRT[Btn5D] != accurate){
			accurate = !accurate;
			if(accurate){
				while(!letIntakeGo){
					wait1Msec(15);
				}
				mobileGoal = !mobileGoal;
				mobileTip = false;
				mobileGoalTip = false;
				if(!mobileGoal){
					if(currentConeStack<=5){
						getOutOfTheWayMid();
						intakeLowered = false;
					}
					else{
						getOutOfTheWay();
						wait1Msec(200 + 25*currentConeStack);
						intakeLowered = false;
					}
					currentConeStack = 0;
				}
				letIntakeGo = false;
			}
		}
		if(vexRT[Btn7L] != baccurate){
			baccurate = !baccurate;
			if(baccurate){
				mobileTip = true;
				mobileGoalTip = !mobileGoalTip;
				mobileGoal = true;
				mobileUntip = false;
			}
		}
		if(vexRT[Btn7U] != caccurate){
			caccurate = !caccurate;
			if(caccurate){
				mobileUntip = !mobileUntip;
				mobileTip = false;
			}
		}
		delay(5);
	}
}

task mobileGoalAuton(){
	mobileGoal = true;
	while(true){
		if(!mobileGoal){
			if(SensorValue(intakeEncoder) < 2370)
				intake(127);
			else if(SensorValue(intakeEncoder) < 2500)
				intake(30);
			else
				intake(5);
		}
		else{
			if(SensorValue(intakeEncoder) > 700)
				intake(-127);
			else
				intake(-2);
		}
		delay(5);
	}
}

void mobileGoalOut(){
	mobileGoal = false;
	while(SensorValue(intakeEncoder) < 2100){
		wait1Msec(80);
	}
	wait1Msec(40);
}

void mobileGoalIn(){
	mobileGoal = true;
	while(SensorValue(intakeEncoder) > 700){
		wait1Msec(80);
	}
	wait1Msec(300);
}

task dataLog(){
	while(true){
		datalogAddValueWithTimeStamp(0, desiredStage1);
		datalogAddValueWithTimeStamp(1, SensorValue(stage1Encoder));
		datalogAddValueWithTimeStamp(2, motor[intakeL]);
		datalogAddValueWithTimeStamp(3, SensorValue(stage2Encoder));
		datalogAddValueWithTimeStamp(4, SensorValue(leftEncoder));
		datalogAddValueWithTimeStamp(5, SensorValue(Gyro));
		datalogAddValueWithTimeStamp(6, -desiredDrive);
		datalogAddValueWithTimeStamp(7, desiredTurn);
	}
}

#include "Team 62 Mark VI Match.c"

void pre_auton() {calibrateGyros();}
//void pre_auton(){}

task autonomous(){
	startTask(dataLog);
	auton();
	//testPID();
	//testTurn();
}

task usercontrol(){
	startTask(dataLog);
	startTask(coneControl);
	startTask(driveControl);
	startTask(mobileGoalMotors);
	resetEncoders();
	if(!autonRan){
		resetLiftEncoders();
		startTask(stage1Control);
		startTask(stage2Control);
		startTask(stallCheck);
		unfoldRobot();
	}
	else{
		startTask(stage1Control);
		startTask(stage2Control);
		startTask(stallCheck);
		autonRan = false;
		//mobileGoal = false;
		//groundSetUpConeWait();
		getOutOfTheWayMid();
	}
}
